{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Input, Output, NgModule, Optional } from '@angular/core';\nimport { Chart, registerables, defaults } from 'chart.js';\nimport { BehaviorSubject } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport { merge } from 'lodash-es';\nlet ThemeService = /*#__PURE__*/(() => {\n  class ThemeService {\n    constructor() {\n      this.colorschemesOptions = new BehaviorSubject(undefined);\n    }\n    setColorschemesOptions(options) {\n      this.pColorschemesOptions = options;\n      this.colorschemesOptions.next(options);\n    }\n    getColorschemesOptions() {\n      return this.pColorschemesOptions;\n    }\n    static {\n      this.ɵfac = function ThemeService_Factory(t) {\n        return new (t || ThemeService)();\n      };\n    }\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: ThemeService,\n        factory: ThemeService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return ThemeService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BaseChartDirective = /*#__PURE__*/(() => {\n  class BaseChartDirective {\n    constructor(element, zone, themeService) {\n      this.zone = zone;\n      this.themeService = themeService;\n      this.type = 'bar';\n      this.plugins = [];\n      this.chartClick = new EventEmitter();\n      this.chartHover = new EventEmitter();\n      this.subs = [];\n      this.themeOverrides = {};\n      this.ctx = element.nativeElement.getContext('2d');\n      this.subs.push(this.themeService.colorschemesOptions.pipe(distinctUntilChanged()).subscribe(r => this.themeChanged(r)));\n    }\n    ngOnChanges(changes) {\n      const requireRender = ['type'];\n      const propertyNames = Object.getOwnPropertyNames(changes);\n      if (propertyNames.some(key => requireRender.includes(key)) || propertyNames.every(key => changes[key].isFirstChange())) {\n        this.render();\n      } else {\n        const config = this.getChartConfiguration();\n        // Using assign to avoid changing the original object reference\n        if (this.chart) {\n          Object.assign(this.chart.config.data, config.data);\n          if (this.chart.config.plugins) {\n            Object.assign(this.chart.config.plugins, config.plugins);\n          }\n          if (this.chart.config.options) {\n            Object.assign(this.chart.config.options, config.options);\n          }\n        }\n        this.update();\n      }\n    }\n    ngOnDestroy() {\n      if (this.chart) {\n        this.chart.destroy();\n        this.chart = void 0;\n      }\n      this.subs.forEach(s => s.unsubscribe());\n    }\n    render() {\n      if (this.chart) {\n        this.chart.destroy();\n      }\n      return this.zone.runOutsideAngular(() => this.chart = new Chart(this.ctx, this.getChartConfiguration()));\n    }\n    update(duration) {\n      if (this.chart) {\n        this.zone.runOutsideAngular(() => this.chart?.update(duration));\n      }\n    }\n    hideDataset(index, hidden) {\n      if (this.chart) {\n        this.chart.getDatasetMeta(index).hidden = hidden;\n        this.update();\n      }\n    }\n    isDatasetHidden(index) {\n      return this.chart?.getDatasetMeta(index)?.hidden;\n    }\n    toBase64Image() {\n      return this.chart?.toBase64Image();\n    }\n    themeChanged(options) {\n      this.themeOverrides = options;\n      if (this.chart) {\n        if (this.chart.config.options) {\n          Object.assign(this.chart.config.options, this.getChartOptions());\n        }\n        this.update();\n      }\n    }\n    getChartOptions() {\n      return merge({\n        onHover: (event, active) => {\n          if (!this.chartHover.observed && !this.chartHover.observers?.length) {\n            return;\n          }\n          this.zone.run(() => this.chartHover.emit({\n            event,\n            active\n          }));\n        },\n        onClick: (event, active) => {\n          if (!this.chartClick.observed && !this.chartClick.observers?.length) {\n            return;\n          }\n          this.zone.run(() => this.chartClick.emit({\n            event,\n            active\n          }));\n        }\n      }, this.themeOverrides, this.options, {\n        plugins: {\n          legend: {\n            display: this.legend\n          }\n        }\n      });\n    }\n    getChartConfiguration() {\n      return {\n        type: this.type,\n        data: this.getChartData(),\n        options: this.getChartOptions(),\n        plugins: this.plugins\n      };\n    }\n    getChartData() {\n      return this.data ? this.data : {\n        labels: this.labels || [],\n        datasets: this.datasets || []\n      };\n    }\n    static {\n      this.ɵfac = function BaseChartDirective_Factory(t) {\n        return new (t || BaseChartDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(ThemeService));\n      };\n    }\n    static {\n      this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n        type: BaseChartDirective,\n        selectors: [[\"canvas\", \"baseChart\", \"\"]],\n        inputs: {\n          type: \"type\",\n          legend: \"legend\",\n          data: \"data\",\n          options: \"options\",\n          plugins: \"plugins\",\n          labels: \"labels\",\n          datasets: \"datasets\"\n        },\n        outputs: {\n          chartClick: \"chartClick\",\n          chartHover: \"chartHover\"\n        },\n        exportAs: [\"base-chart\"],\n        features: [i0.ɵɵNgOnChangesFeature]\n      });\n    }\n  }\n  return BaseChartDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst baseColors = [[255, 99, 132], [54, 162, 235], [255, 206, 86], [231, 233, 237], [75, 192, 192], [151, 187, 205], [220, 220, 220], [247, 70, 74], [70, 191, 189], [253, 180, 92], [148, 159, 177], [77, 83, 96]];\nconst builtInDefaults = {\n  plugins: {\n    colors: {\n      enabled: false\n    }\n  },\n  datasets: {\n    line: {\n      backgroundColor: context => rgba(generateColor(context.datasetIndex), 0.4),\n      borderColor: context => rgba(generateColor(context.datasetIndex), 1),\n      pointBackgroundColor: context => rgba(generateColor(context.datasetIndex), 1),\n      pointBorderColor: '#fff'\n    },\n    bar: {\n      backgroundColor: context => rgba(generateColor(context.datasetIndex), 0.6),\n      borderColor: context => rgba(generateColor(context.datasetIndex), 1)\n    },\n    get radar() {\n      return this.line;\n    },\n    doughnut: {\n      backgroundColor: context => rgba(generateColor(context.dataIndex), 0.6),\n      borderColor: '#fff'\n    },\n    get pie() {\n      return this.doughnut;\n    },\n    polarArea: {\n      backgroundColor: context => rgba(generateColor(context.dataIndex), 0.6),\n      borderColor: context => rgba(generateColor(context.dataIndex), 1)\n    },\n    get bubble() {\n      return this.doughnut;\n    },\n    get scatter() {\n      return this.doughnut;\n    },\n    get area() {\n      return this.polarArea;\n    }\n  }\n};\nfunction rgba(colour, alpha) {\n  return 'rgba(' + colour.concat(alpha).join(',') + ')';\n}\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nfunction getRandomColor() {\n  return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\n}\n/**\n * Generate colors\n */\nfunction generateColor(index = 0) {\n  return baseColors[index] || getRandomColor();\n}\nlet NgChartsConfiguration = /*#__PURE__*/(() => {\n  class NgChartsConfiguration {\n    constructor() {\n      this.generateColors = true;\n    }\n    static {\n      this.ɵfac = function NgChartsConfiguration_Factory(t) {\n        return new (t || NgChartsConfiguration)();\n      };\n    }\n    static {\n      this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n        token: NgChartsConfiguration,\n        factory: NgChartsConfiguration.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return NgChartsConfiguration;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nChart.register(...registerables);\nlet NgChartsModule = /*#__PURE__*/(() => {\n  class NgChartsModule {\n    constructor(config) {\n      if (config?.plugins) Chart.register(...config.plugins);\n      const ngChartsDefaults = merge(config?.generateColors ? builtInDefaults : {}, config?.defaults || {});\n      defaults.set(ngChartsDefaults);\n    }\n    static forRoot(config) {\n      return {\n        ngModule: NgChartsModule,\n        providers: [{\n          provide: NgChartsConfiguration,\n          useValue: config\n        }]\n      };\n    }\n    static {\n      this.ɵfac = function NgChartsModule_Factory(t) {\n        return new (t || NgChartsModule)(i0.ɵɵinject(NgChartsConfiguration, 8));\n      };\n    }\n    static {\n      this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n        type: NgChartsModule\n      });\n    }\n    static {\n      this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n    }\n  }\n  return NgChartsModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of ng2-charts\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BaseChartDirective, NgChartsConfiguration, NgChartsModule, ThemeService, baseColors };\n//# sourceMappingURL=ng2-charts.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}